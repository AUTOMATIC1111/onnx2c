#include "error.h"
#include "graph.h"
#include "op.h"
#include "util.h"
#include <iostream>

using namespace toC;

void Graph::print_header(std::ostream &dst)
{
	print_file_frontmatter(dst);
}

void Graph::print_source(std::ostream &dst)
{
	print_file_frontmatter(dst);
	dst << std::endl;
	print_includes(dst);
	dst << std::endl;
	print_global_tensors(dst);
	dst << std::endl;
	print_functions(dst);
	dst << std::endl;
	print_interface_function(dst);
}


void Graph::print_file_frontmatter(std::ostream &dst)
{
	dst << "// This file is computer-generated by onnx2c " << std::endl;
	dst << "// (TODO: add creating command line here)" << std::endl;
	dst << "// (TODO: print creation date here )" << std::endl;
	dst << std::endl;
	dst << "// ONNX model:" << std::endl;
	dst << "// produced by " << model.producer_name();
	dst << ", version " << model.producer_version() << std::endl;
	dst << "// Model documentation: " << std::endl;
	// TODO: beware & check for maliciously formatted doc strings!!!
	// (and when you do that, also append "//" to every newlin in the doc_string for nicer printing :)
	dst << "/*" << std::endl << model.doc_string() << std::endl << "*/" << std::endl;
}

void Graph::print_tensor_initializer(std::ostream &dst, Tensor *t, int dim, int offs)
{
	if( t->data_dim[dim] == 0 )
		return; 

	for( int i=0; i<dim; i++)
		dst << "  ";

	dst << "{" ;

	if(   dim < (tensor_max_dim-1)
	   && t->data_dim[dim+1] != 0 ) {
		dst << std::endl;
		for( int i=0; i<t->data_dim[dim]; i++ )
		{
			print_tensor_initializer(dst, t, dim+1, offs+i*t->data_dim[dim+1]);
			if( i <(t->data_dim[dim]-1) )
				dst << ",";
			dst << std::endl;
		}
	}

	else
		for( int i=0; i<t->data_dim[dim]; i++)
		{
			int element=offs+i;
			switch(t->data_type)
			{
				case onnx::TensorProto_DataType_FLOAT:
				{
					float *f = static_cast<float*>(t->data_buffer);
					dst << std::showpoint << f[element]<< "f";
					break;
				}
				case onnx::TensorProto_DataType_INT32:
				{
					int32_t *f = static_cast<int32_t*>(t->data_buffer);
					dst << f[element];
					break;
				}
				default:
					ERROR("unimplemented printing of initialized datatype " << t->data_type_str());
			
			}
			if( i <(t->data_dim[dim]-1) )
				dst << ", ";
		}
	dst << "}";
}

void Graph::print_global_tensors(std::ostream &dst)
{
	for( auto t : tensors )
	{
		if( t->generate == false )
			continue;

		dst << "/* " << t->name << "*/" << std::endl;
		dst << "static ";
		print_tensor(dst, t);
		if( t->initialize ) {
			dst << " = "<<std::endl;
			print_tensor_initializer(dst, t, 0, 0);
		}

		dst << ";" << std::endl;
	}
}

/* Prints the "float foo[N][M]" part of a tensor */
void Graph::print_tensor(std::ostream &dst, const Tensor *t)
{
	dst << t->data_type_str() << " ";
	dst << t->cname();
	for(int i=0; i<tensor_max_dim; i++) {
		if( t->data_dim[i] == 0 )
			break;
		dst << "[" << t->data_dim[i] << "]";
	}
}

void Graph::print_functions(std::ostream &dst)
{
	for( auto n : nodes ) {
		dst << "static inline void ";
		dst << n->name << "( ";
		for( auto t : n->inputs ){
			print_tensor(dst, t);
			// TODO: print this only N-1 first times
			dst << ", ";
		}
		//TODO: handle multi-output case
		for( auto t: n->outputs)
			print_tensor(dst, t);

		dst << " )";
		dst <<  std::endl << "{" << std::endl;

		n->op->print(dst, n);

		dst << "}" << std::endl << std::endl;
	}
}

void Graph::print_includes(std::ostream &dst)
{
	dst << "#include <stdint.h>" << std::endl;
}

void Graph::print_interface_function(std::ostream &dst)
{

	// TODO: take the interface function name from the ONNX file name
	dst << "void entry(" ;
	for ( auto i : model.graph().input() ) {
		Tensor *t = getIoTensor(i);
		print_tensor(dst, t);
		dst << ", ";
	}
	for ( auto i : model.graph().output() ) {
		Tensor *t = getIoTensor(i);
		print_tensor(dst, t);
	}
	dst << ") {" << std::endl;

	// since nodes were resolved from graph inputs in the order there were
	// node inputs resolved, the nodes vector is now sorted in order so that
	// we don't need to check dependancies :)
	for( auto n : nodes )
	{
		dst << "\t" << cify_name(n->name) << "( ";
		for( auto i : n->inputs ) {
			dst << i->cname();
			dst << ", ";
		}
		for( auto i : n->outputs ) {
			dst << i->cname();
		}
		dst << ");" << std::endl;
	}

	dst << "}" << std::endl;
}
